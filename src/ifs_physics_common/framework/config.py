# -*- coding: utf-8 -*-
#
# Copyright 2022-2024 ETH Zurich
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations
import os
import numpy as np
from pydantic import BaseModel, validator
import socket
from typing import Any, Literal, Optional, Union


class DataTypes(BaseModel):
    """Specify the datatypes for bool, float and integer fields."""

    bool: type
    float: type
    int: type

    @staticmethod
    def with_precision(precision: Literal["double", "single"]) -> DataTypes:
        if precision == "double":
            return DataTypes(bool=bool, float=np.float64, int=np.int64)
        elif precision == "single":
            return DataTypes(bool=bool, float=np.float32, int=np.int32)
        else:
            raise ValueError("Either `double` or `single` precision supported.")


class GT4PyConfig(BaseModel):
    """Gather options controlling the compilation and execution of the code generated by GT4Py."""

    backend: str
    backend_opts: dict[str, Any] = {}
    build_info: Optional[dict[str, Any]] = None
    device_sync: bool = True
    dtypes: DataTypes = DataTypes(bool=bool, float=float, int=int)
    exec_info: dict[str, Any] = {}
    managed: Union[bool, str] = "gt4py"
    rebuild: bool = False
    validate_args: bool = False
    verbose: bool = True

    @validator("exec_info")
    @classmethod
    def set_exec_info(cls, v: Optional[dict[str, Any]]) -> dict[str, Any]:
        v = v or {}
        return {**v, "__aggregate_data": True}

    def reset_exec_info(self) -> None:
        self.exec_info = {"__aggregate_data": self.exec_info.get("__aggregate_data", True)}

    def with_backend(self, backend: Optional[str]) -> GT4PyConfig:
        args = self.dict()
        if backend is not None:
            args["backend"] = backend
        return GT4PyConfig(**args)

    def with_dtypes(self, dtypes: DataTypes) -> GT4PyConfig:
        args = self.dict()
        args["dtypes"] = dtypes
        return GT4PyConfig(**args)

    def with_validate_args(self, flag: bool) -> GT4PyConfig:
        args = self.dict()
        args["validate_args"] = flag
        return GT4PyConfig(**args)


class PythonConfig(BaseModel):
    """Gather options controlling execution of Python/GT4Py code."""

    # domain
    num_cols: int

    # validation
    enable_validation: bool
    input_file: str
    reference_file: str
    atol: Optional[float] = None
    rtol: Optional[float] = None

    # run
    num_runs: int
    num_threads: int = -1

    # low-level and/or backend-related
    precision: Literal["double", "single"]
    data_types: DataTypes
    gt4py_config: GT4PyConfig
    sympl_enable_checks: bool

    @validator("num_threads", always=True)
    @classmethod
    def set_num_threads(cls, v: int) -> int:
        if v <= 0:
            return int(os.environ.get("OMP_NUM_THREADS", 1))
        else:
            return v

    @validator("gt4py_config")
    @classmethod
    def add_dtypes(cls, v: GT4PyConfig, values: dict[str, Any]) -> GT4PyConfig:
        return v.with_dtypes(values["data_types"])

    def with_backend(self, backend: Optional[str]) -> PythonConfig:
        args = self.dict()
        args["gt4py_config"] = GT4PyConfig(**args["gt4py_config"]).with_backend(backend).dict()
        return PythonConfig(**args)

    def with_checks(self, enabled: bool) -> PythonConfig:
        args = self.dict()
        args["gt4py_config"] = (
            GT4PyConfig(**args["gt4py_config"]).with_validate_args(enabled).dict()
        )
        args["sympl_enable_checks"] = enabled
        return PythonConfig(**args)

    def with_num_cols(self, num_cols: Optional[int]) -> PythonConfig:
        args = self.dict()
        if num_cols is not None:
            args["num_cols"] = num_cols
        return PythonConfig(**args)

    def with_num_runs(self, num_runs: Optional[int]) -> PythonConfig:
        args = self.dict()
        if num_runs is not None:
            args["num_runs"] = num_runs
        return PythonConfig(**args)

    def with_precision(self, precision: Literal["double", "single"]) -> PythonConfig:
        args = self.dict()
        args["precision"] = precision
        args["data_types"] = self.data_types.with_precision(precision)
        return PythonConfig(**args)

    def with_validation(
        self, enabled: bool, atol: Optional[float] = None, rtol: Optional[float] = None
    ) -> PythonConfig:
        args = self.dict()
        args["enable_validation"] = enabled
        args["atol"] = atol
        args["rtol"] = rtol
        return PythonConfig(**args)


class FortranConfig(BaseModel):
    """Gather options controlling execution of FORTRAN code."""

    build_dir: str
    precision: Literal["double", "single"]
    variant: str
    nproma: int
    num_cols: int
    num_runs: int
    num_threads: int

    def with_build_dir(self, build_dir: str) -> FortranConfig:
        args = self.dict()
        args["build_dir"] = build_dir
        return FortranConfig(**args)

    def with_nproma(self, nproma: int) -> FortranConfig:
        args = self.dict()
        args["nproma"] = nproma
        return FortranConfig(**args)

    def with_num_cols(self, num_cols: int) -> FortranConfig:
        args = self.dict()
        args["num_cols"] = num_cols
        return FortranConfig(**args)

    def with_num_runs(self, num_runs: int) -> FortranConfig:
        args = self.dict()
        args["num_runs"] = num_runs
        return FortranConfig(**args)

    def with_num_threads(self, num_threads: int) -> FortranConfig:
        args = self.dict()
        args["num_threads"] = num_threads
        return FortranConfig(**args)

    def with_precision(self, precision: str) -> FortranConfig:
        args = self.dict()
        args["precision"] = precision
        return FortranConfig(**args)

    def with_variant(self, variant: str) -> FortranConfig:
        args = self.dict()
        args["variant"] = variant
        return FortranConfig(**args)


class IOConfig(BaseModel):
    """Gather options for I/O."""

    output_csv_file: Optional[str]
    host_name: str

    @validator("output_csv_file")
    @classmethod
    def check_extension(cls, v: Optional[str]) -> Optional[str]:
        if v is None:
            return v

        basename, extension = os.path.splitext(v)
        if extension == "":
            return v + ".csv"
        elif extension == ".csv":
            return v
        else:
            return basename + ".csv"

    @validator("host_name", pre=True)
    @classmethod
    def set_host_name(cls, v: Optional[str]) -> str:
        return v or socket.gethostname()

    def with_host_name(self, host_name: Optional[str]) -> IOConfig:
        args = self.dict()
        args["host_name"] = host_name
        return IOConfig(**args)

    def with_output_csv_file(self, output_csv_file: Optional[str]) -> IOConfig:
        args = self.dict()
        args["output_csv_file"] = output_csv_file
        return IOConfig(**args)
